# Проект для студентов курса LevelUp Python Level 1: Игра "Битва"

## План действий:

### Выбрать персонажей для игры и картинки для них

- Студенту необходимо самостоятельно придумать себе персонажей и категории.

- Если возникают сложности при выборе персонажей и категории, 
  то обратиться за помощью.

- Персонажи должны делиться на категории 
  (минимум 2 категории, желательно больше).

- В каждой категории должны быть различные персонажи 
  (минимум 2 персонажа, желательно больше)

- Персонажами и категориями может быть что угодно. 
  Можно делать по мотивам игр или фильмов, юмористические варианты 
  или просто любые.

- Для каждого персонажа должно быть найдено и сохранено изображение. 
  Все картинки должны храниться в одной директории в проекте (пример из лекций: [images](../project/images)).
  
- Придумать какие категории имеют слабость перед другими категориями.

- Придумать точки удара/защиты.
  
- Пример 1 ("серьезный"):
    - Категории: виды стихий
        - **Вода**
        - **Земля**
        - **Воздух**
    - Персонажи (по категориям):
        - Вода
            - **Золотая рыбка**
            - **Дельфин**
        - Земля
            - **Черепаха**
            - **Собака**
        - Воздух
            - **Птица**
            - **Пчела**
    - Слабости:
        - **Вода** уязвима перед воздухом (воздух сушит воду)
        - **Земля** уязвима перед водой (вода размачивает землю)
        - **Воздух** уязвима перед землей (земля пылит воздух)
    - Точки удара/защиты:
        - **Голова**
        - **Тело**
        - **Хвост**
    
- Пример 2 ("юмористический"):
    - Категории:
        - **Еда из KFC**
        - **Сырые овощи**
        - **Десерты**
    - Персонажи:
        - Еда из KFC
            - **Бургер**
            - **Куриные крылышки**
        - Сырые овощи
            - **Морковь**
            - **Шпинат**
        - Десерты 
            - **Кусок торта**
            - **Эклер**
    - Слабости
        - **Фаст-фуд** уязвим перед овощами
        - **Овощи** уязвимы перед десертами
        - **Десерты** уязвимы перед фаст-фудом
    - Точки удара/защиты:
        - **Центр**
        - **Верх**
        - **Низ**
    
### Состояние персонажей реализовать как `Enum`
- Создать отдельный модуль с состояниями персонажей в виде перечислений.

- Значения элементов перечисления должны генерироваться с помощью функции `auto()`.

- Для персонажа существует всего 2 состояния:
    - Готов к битве
    - Побежден
    
- Пример из лекций: [pokemon_state.py](../project/combat/pokemon_state.py)

### Варианты результатов битвы реализовать как `Enum`
- Создать отдельный модуль с возможными исходами битвы в виде перечислений.

- Значения элементов перечисления должны генерироваться с помощью функции `auto()`.

- Для персонажа существует всего 3 возможных исходов битвы:
    - Победа (игрока)
    - Поражение (игрока)
    - Ничья (игрок и бот были побеждены на одном ходу)
    
- Пример из лекций: [game_result.py](../project/combat/game_result.py)


### Категории персонажей реализовать как `Enum`
- Создать отдельный модуль с категориями персонажей в виде перечислений.

- Значения элементов перечисления должны генерироваться с помощью функции `auto()`.

- Класс категории должен содержать:
    - Метод получения минимального значения (`value`) элемента категории (`classmethod`).
    - Метод получения максимального значения (`value`) элемента категории (`classmethod`).
    
- Пример из лекций: [pokemon_type.py](../project/combat/pokemon_type.py)

### Персонажей по категориям реализовать как `dict`
- Создать отдельный модуль с персонажами по категориям в виде `dict`.

- Шаблон заполнения `dict`
  (категории, 
  имена персонажей, 
  пути к изображениям персонажей):
```python
{
    category1:
        {name1: image1_path, 
         name2: image2_path, ...},

    category2:
        {name3: image3_path, 
         name4: image4_path, ...}, 
    ...
}
```

- Пример из лекций: [pokemon_by_type.py](../project/combat/pokemon_by_type.py)

### Слабости по категориям реализовать как `dict`
- Создать отдельный модуль со слабостями по категориям в виде `dict`.

- Шаблон заполнения `dict`
  (категории: категории, перед которыми есть уязвимость):
```python
{
    category1: (category2, ...),

    category2: (category1, category3 ...), 
    ...
}
```

- Пример из лекций: [pokemon_types_weaknesses.py](../project/combat/pokemon_types_weaknesses.py)


### Точки удара/защиты реализовать как `Enum`
- Создать отдельный модуль с точками удара/защиты в виде перечислений.

- Значения элементов перечисления должны генерироваться с помощью функции `auto()`.

- Класс категории должен содержать:
    - Метод (`classmethod`) получения минимального значения (`value`) элемента категории.
    - Метод (`classmethod`) получения максимального значения (`value`) элемента категории.
    - Метод (`classmethod`) проверки наличия имени (`name`) в именах перечисления (`_member_names_`).

- Пример из лекций: [body_part.py](../project/combat/body_part.py)

### Реализовать класс игрока

- *Игрок — это значит любой из персонажей.
  
- Создать отдельный модуль с классом игрока.
  
- Класс игрока должен содержать:
    - Метод `__init__`
        - Принимает в качестве входных параметров:
            - имя персонажа
            - тип персонажа
        - Определяет поля класса:
            - имя персонажа
            - категория персонажа
            - категорию к которой персонаж испытывает слабость
            - очки жизни персонажа
            - точку защиты
            - точку удара
            - мощность удара
            - состояние (готов к битве/побежден)
    
    - Метод приведения к строке `__str__`, который возвращает строку содержащую:
        - имя персонажа
        - категория персонажа
        - очки жизни персонажа
    
    - Метод для обновления следующего шага
      (куда бить и что защищать на следующем шаге игры)
        - Принимает в качестве входных параметров:
            - точку защиты для следующего удара
            - точку удара для следующего удара
      
    - Метод для обработки полученного удара
        - Принимает в качестве входных параметров:
            - точку удара от противника
            - мощность удара противника
            - категорию противника
        - Примерная логика обработки:
            - Если выбранная точка защиты совпадает с точкой удара от противника, то удар нейтрализуется.
            - Если персонаж имеет уязвимость перед категорией противника, то мощность удара противника умножается на какую-то величину.
            - Если после удара очки жизни персонажа `<= 0`, то состояние персонажа меняется на Побежден.
    
- Пример из лекций: [pokemon.py](../project/combat/pokemon.py)


### Реализовать класс non-player character (NPC)

- *NPC — неигровой персонаж, противник, "бот", игрок выбирающий себе персонажа и удары/защиты случайным образом.

- Класс NPC должен быть унаследован от класса игрока, так как является его расширением.

- Класс игрока должен содержать:
    - Метод `__init__`
        - Не принимает входных параметров
        - Случайным образом выбирает себе категорию и имя персонажа
        - Производит инициализацию родительского класса с помощью случайно выбранной категории и имени персонажа
    
    - Метод для обновления следующего шага
          (куда бить и что защищать на следующем шаге игры)
        - Не принимает входных параметров.
        - Случайным образом выбирает точку защиты для следующего удара
        - Случайным образом выбирает точку удара для следующего удара  
        - Передает в аналогичный метод родительского класса свой выбор точек защиты/удара
    
- Пример из лекций: [pokemon_npc.py](../project/combat/pokemon_npc.py)


### Подготовка Telegram бота

- В Telegram найти бота с именем `@BotFather`.
    - Создать нового бота с помощью команды `/newbot`
    - Сохранить токен в текстовый файл в проекте (пример из лекций: [bot_token.txt](../project/combat/bot_token.txt))

- Установить пакет `pyTelegramBotAPI`
```shell
pip install pyTelegramBotAPI
```

### Реализовать логику игры в Telegram боте

- Токен для доступа к Telegram боту необходимо читать из файла 
  (пример файла из лекций: [bot_token.txt](../project/combat/bot_token.txt)).
  
- Реализовать команду для Telegram бота для начала битвы. 
  Перед началом битвы бот должен спросить хочет ли пользователь начать игру. 
  Для этого использовать клавиатуру типа `ReplyKeyboardMarkup` и метод `register_next_step_handler`.

- Если пользователь согласен начать битву, то:
    - Вначале создается объект NPC и выводятся данные (картинка и данные из метода `__str__`)
      случайно выбранного персонажа. 
    - Затем пользователю предлагается выбрать категорию своего персонажа (клавиатура типа `InlineKeyboard`).
    - После выбора категории пользователю предлагается 
      (выводится картинка и название) выбрать персонажа (клавиатура типа `InlineKeyboard`).
    - После выбора персонажа пользователем создается его объект персонажа.
    
- После того как созданы объекты NPC и пользовательский персонаж начинается битва. 
  Каждый шаг битвы состоит из следующих шагов:
    - NPC случайным образом выбирает точки защиты/удара.
    - Пользователю предлагается выбрать точки защиты/удара 
      с помощью клавиатуры типа `ReplyKeyboardMarkup`.
    - Результат выбора обновляет состояние объектов NPC и 
      пользовательского персонажа.
    - Вначале персонаж NPC получает удар от пользовательского персонажа и 
      выводит результат удара.
    - Затем пользовательский персонаж получает удар от персонажа NPC.
    - Результаты обмена ударами обрабатывается 
      (кто-то уже проиграл или оба проиграли, или битва продолжается).
    - Если битва завершена, то статистика по результатам игр должна обновиться.
    
- Необходимо сохранять статистику результатов игр 
  для пользователей (по id) в файл с помощью модуля `json`. Пример:
```python
{
    user_id_1: {'wins': 1, 
                'losses': 0, 
                'standoff': 2},
    user_id_2: {'wins': 0, 
                'losses': 3, 
                'standoff': 0},
    ...
}
```

- При запуске бота необходимо загружать файл со статистикой результатов игр. 
  Если файл не существует, то есть еще не было ни одной битвы, 
  то при попытке открыть файл перехватывать исключение и 
  печатать сообщение об этом. 
  Для этой задачи рекомендуется создать отдельную функцию.
  
- Реализовать функцию обновления статистики результатов игр. 
  При этом добавить в переменную обновленные данные и 
  обновить информацию в файле.
  
- Реализовать команду для Telegram бота для получения статистики результатов игр.

- Основные действия должны "логироваться" с помощью функции print().

- Пример из лекций: [telebot_pokemon_combat.py](../project/combat/telebot_pokemon_combat.py)

### Реализовать тесты для класса игрока

- Протестировать метод `__init__`.

- Протестировать метод `__str__`.

- Пример из лекций: [pokemon_test.py](../project/tests/pokemon_test.py)


### Реализовать тесты для класса non-player character (NPC)

- Протестировать метод `__init__`. 
  Использовать `seed` из модуля `random`.

- Протестировать метод `__str__`. 
  Использовать `seed` из модуля `random`.

- Пример из лекций: [pokemon_npc_test.py](../project/tests/pokemon_npc_test.py)